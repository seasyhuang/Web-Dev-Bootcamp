<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="notes-style.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
        crossorigin="anonymous">

    <title>Backend Notes</title>
  </head>
  <body>

    <!--Navigation bar-->
    <iframe src="notes-navbar4.html" frameborder="0" width="100%" height="70px"></iframe>

    <div class="container">
      <div class="jumbotron pl-5">
        <h1 class="display-2 text-info">Backend</h1>
        <h2 class="display-5">Section 22-</h2>
      </div>

      <ul>
        <li class="lecture">Lecture 241: Backend basics</li>
        <ul>
          <li>how the internet works: 60s ver</li>
          <li>url (udemy) --> ip address --> http request sent to ip address</li>
          <li>server (udemy) responds --> server sends html/css/js to me as http response --> browser renders html/css/js (page content) to what we see now </li>
          <li>static vs dynamic webpages</li>
          <ul class="inner">
            <li>static: same css html js every time</li>
            <li>dynamic: different content every time - server decides new content</li>
          </ul>
          <li>stack: all the web technology a web app uses - the choices of technology the developer uses</li>
          <li>backend has a lot of variance: js, php, ruby, python</li>
          <li>different websites use different stacks/technologies</li>
          <li>backend: the logic </li>
          <ul class="inner">
            <li>we'll be using node js, express framework, and mongodb</li>
          </ul>
        </ul>

        <li class="lecture">Lecture 242/3: Postman (HTTP in Depth)</li>
        <ul>
          <li>chrome app called Postman - you can send requests from many places</li>
          <li>request information - <code>get</code> </li>
          <li>update information - <code>put, patch</code> </li>
          <li>delete something - <code>delete</code> </li>
          <li>remember that http is a protocol</li>
          <li>example <code>get</code> request:</li>
          <ul class="inner">
            <li><code>body</code> is the content</li>
            <li><code>header</code> is metadata from request</li>
            <li>header <code>content-Type</code> says what kind of response you're getting (ex <code>text/html</code>)</li>
            <li><code>status</code> - 200 is ok</li>
            <li>query example: <code>q=cats</code>, q is query, cats is what we're searching for in the database</li>
          </ul>
        </ul>

        <li class="lecture">Lecture 244/5: backend workflow 1-2</li>
        <ul>
          <li>concepts of workflow</li>
          <li>file has setup, routes, etc</li>
          <li>server file written in js - listens for requests and sends responds</li>
          <li>start server at port 3000 - you can open the webpage on your browser on <code>localhost:3000</code> </li>
          <li><code>routes</code> - listens for (ex) <code>get</code>, decides what file to send back, (ex) renders("home") </li>
          <ul class="inner">
            <li>term: "get route", "post route", etc</li>
          </ul>
          <li>adding information: <code>post</code> request, which 99% of the time is done through a form</li>
          <li>ex: in the post request <code>body</code>, send name(=charlie) and breed(=golden)</li>
          <li>need a <code>form</code> in the html for this to make sense:</li>
          <ul class="inner">
            <li>form <code>action</code> - where you want to send, <code>method</code> - post</li>
            <li>for form inputs: input <code>name</code> is the important part - tells the form what to put in the post request body (see above) </li>
          </ul>
          <li>after making post request, will always send get request after (even if you didn't explicitly ask) back to the same page </li>
        </ul>

        <li class="lecture">Lecture 246-8: cloud9</li>
        <ul>
          <li>ignoring cloud9</li>
          <li>The original c9.io has been closed down</li>
          <li>alternative: GoormIDE</li>
          <li>ignoring the alternative - using terminal (setting up a <strong>local development environment</strong>)</li>
          <li><a href="https://zarkom.net/blogs/mac-local-coding-environment-6283">instructions</a> </li>
          <li><a href="https://www.youtube.com/watch?v=lGKf_7ugFUQ"></a>How to install and use Node Version Manager (NVM)</li>
          <li><a href="https://www.youtube.com/watch?v=DX15WbKidXY"></a>install MongoDB </li>
          <li>bottom of Cloud9 browser interface: <strong>command line (terminal)</strong> --> <strong>same bash terminal</strong></li>
          <li>biggest portion of the screen: Cloud9’s built-in code <strong>editor</strong> -->  <strong>whatever text editor</strong></li>
          <li>left-hand sidebar: file view in Cloud9 --> Mac OS X file manager (Finder)</li>
          <li>Running and previewing our apps locally: </li>
          <ul class="inner">
            <li>To run and preview your projects/applications, you need to use your system terminal, change directories to navigate to your project folder and then run <code>node app.js</code> to start the application (just like Colt does in Cloud9) </li>
            <li>important change: need to <strong>manually define the port</strong> that the app is listening to (this is handled differently in Cloud9)</li>
            <li><strong>DON'T</strong> use <code>app.listen() </code> </li>
            <li>instead: <code>
var port = process.env.PORT || 3000;
app.listen(port, function () {
  console.log("Server Has Started!");
});
            </code> </li>
            <li>--> Then, you will be able to preview your app by going into your browser at <code>localhost:3000 </code> </li>
          </ul>
          <li>heroku:</li>
          <ul class="inner">
            <li>a service which we use to publish our Node.js application on the internet, towards the end of the course</li>
            <li><a href="https://devcenter.heroku.com/articles/heroku-cli#download-and-install">installation</a> </li>
          </ul>
        </ul>

        <h1 class="my-3 text-info">Command Line</h1>
        <li class="lecture">Lecture 249: solutions on github</li>
        <ul>
          <li><a href="https://github.com/nax3t/webdevbootcamp">github</a> </li>
        </ul>

        <li class="lecture">Lecture 250: introduction to the command line</li>
        <ul>
          <li><a href="https://www.davidbaumgold.com/tutorials/command-line/">Getting to Know the Command Line</a> </li>
          <li><a href="http://matt.might.net/articles/basic-unix/">Survival guide for Unix newbies</a> </li>
          <li>you can start a node server on the command line</li>
        </ul>

        <li class="lecture">Lecture 251: CD, LS</li>

        <li class="lecture">Lecture 252: touch, mkdir</li>

        <li class="lecture">Lecture 253: removing files and folders</li>
        <ul>
          <li>remove: <code>rm</code> </li>
          <li>remove directories: <code>rm -rf</code> (recursive force) </li>
        </ul>

        <li class="lecture">Lecture 254: command line exercise</li>
        <ul>
          <li>pretty basic</li>
        </ul>

        <h1 class="my-3 text-info">NodeJS</h1>
        <li class="lecture">Lecture 255: indroduction to node</li>
        <ul>
          <li>what is node? a js runtime built on chrome's v8 javascript engine</li>
          <ul class="inner">
            <li>all our js was previously run on the browser</li>
            <li>node is a way to write js on the serverside (backend)</li>
            <li>before node, backend was python, java, ruby, etc - now we can write js on the server side</li>
          </ul>
          <li>why are we learning it?</li>
          <ul class="inner">
            <li>it's popular</li>
            <li>js overtook ruby in 2012 as most popular language</li>
            <li>php vs nodejs:</li>
            <ul class="inner">
              <li>large community</li>
              <li>php has been around for a long time</li>
              <li>node has great libraries and is in js</li>
              <li>node is high-performance</li>
            </ul>
            <li>node is in js: don't need to pick up another language</li>
            <li>best first server side language to start out with</li>
          </ul>
          <li>it doesn't matter longterm - easy to transition to another language in the future</li>
        </ul>

        <li class="lecture">Lecture 265: using node</li>
        <ul>
          <li>node console: open in the terminal, type/use js, etc</li>
          <li>not that useful</li>
          <li>can't use <code>alert</code>, <code>document</code>, etc - those come with the browser</li>
          <li>how to "run a file with node" - execute a js file in the command line</li>
          <li>use in console: <code>node [filename]</code> (see ex: hello.js)</li>
        </ul>

        <li class="lecture">Lecture 266-7: node exercises</li>
        <ol>
          <li><a href="introtonode/echo.js">echo.js</a> </li>
          <li><a href="introtonode/grader.js">grader.js</a> </li>
        </ol>

        <li class="lecture">Lecture 268: intro to npm</li>
        <ul>
          <li>npm: <strong>node pacakge manager</strong> </li>
          <li>what is it?</li>
          <ul class="inner">
            <li>NPM is a package manager for js</li>
            <li>including a library - you can't just use a script tag in backend</li>
            <li>packages someone else has written that you can include</li>
            <li>npm has a command line tool - easy to install packages</li>
          </ul>
          <li>we'll be downloading <code>express</code> (a framework), <code>mongoose</code>, <code>morgan</code>, <code>body-parser</code>, and more</li>
        </ul>

        <li class="lecture">Lecture 269-70: installing npm packages</li>
        <ol>
          <li><a href="introtonode/demoapp">demoapp folder</a> </li>
          <li><a href="introtonode/demoapp/app.js">app.js</a> </li>
        </ol>
        <ul>
          <li>note: Also (for the next lecture), the cat-me package has changed slightly since the video was created. Now, when you open up the cat-me folder from within the node_modules directory you will find all of the cats inside of cats.json (instead of cats.js).</li>
          <li>using <code>npm install</code> </li>
          <li>using <code>require()</code> to include packages</li>
          <li>after running <code>npm install cat-me</code>, files will be downloaded in the <code>nodemodules</code> folder inside our demoapp folder (either will create this folder if it doesn't exist, or add to the folder if it does)</li>
          <li>example: <code>var catMe = require("cat-me"); console.log(cat());</code> </li>
          <li>also did same thing with <code>knock-knock-jokes</code> </li>
        </ul>

        <li class="lecture">Lecture 271-2: npm faker exercise</li>
        <ol>
          <li><a href="introtonode/MyShop/listProducts.js">listProducts.js</a> </li>
        </ol>
        <ul>
          <li><a href="https://www.npmjs.com/package/faker">faker</a> is a pretty commonly used package for generating random fake data </li>
        </ul>


      </ul>
    </div>

    <script src="eventlistener.js" charset="utf-8"></script>
  </body>
</html>
